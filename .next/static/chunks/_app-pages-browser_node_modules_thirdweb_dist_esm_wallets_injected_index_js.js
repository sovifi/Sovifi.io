"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_thirdweb_dist_esm_wallets_injected_index_js"],{

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/injected/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/wallets/injected/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoConnectInjectedWallet: () => (/* binding */ autoConnectInjectedWallet),\n/* harmony export */   connectInjectedWallet: () => (/* binding */ connectInjectedWallet),\n/* harmony export */   getInjectedProvider: () => (/* binding */ getInjectedProvider),\n/* harmony export */   isInjectedWallet: () => (/* binding */ isInjectedWallet)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/typedData.js\");\n/* harmony import */ var _chains_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../chains/utils.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/chains/utils.js\");\n/* harmony import */ var _utils_address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/address.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/address.js\");\n/* harmony import */ var _utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/encoding/hex.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/hex.js\");\n/* harmony import */ var _utils_chains_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/chains.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/utils/chains.js\");\n/* harmony import */ var _utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/normalizeChainId.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/utils/normalizeChainId.js\");\n/* harmony import */ var _mipdStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mipdStore.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/injected/mipdStore.js\");\n/* harmony import */ var _utils_signatures_helpers_parseTypedData_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/signatures/helpers/parseTypedData.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/signatures/helpers/parseTypedData.js\");\n\n\n\n\n\n\n\n\n/**\n * Checks if the provided wallet is an injected wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is an injected wallet, false otherwise.\n */\nfunction isInjectedWallet(wallet) {\n    return !!(0,_mipdStore_js__WEBPACK_IMPORTED_MODULE_0__.injectedProvider)(wallet.id);\n}\n// TODO: save the provider in data\nfunction getInjectedProvider(walletId) {\n    const provider = (0,_mipdStore_js__WEBPACK_IMPORTED_MODULE_0__.injectedProvider)(walletId);\n    if (!provider) {\n        throw new Error(`No injected provider found for wallet: \"${walletId}\"`);\n    }\n    return provider;\n}\n/**\n * @internal\n */\nasync function connectInjectedWallet(id, options, emitter) {\n    const provider = getInjectedProvider(id);\n    const addresses = await provider.request({\n        method: \"eth_requestAccounts\",\n    });\n    const addr = addresses[0];\n    if (!addr) {\n        throw new Error(\"no accounts available\");\n    }\n    // use the first account\n    const address = (0,_utils_address_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(addr);\n    // get the chainId the provider is on\n    const chainId = await provider\n        .request({ method: \"eth_chainId\" })\n        .then(_utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__.normalizeChainId);\n    let connectedChain = options.chain && options.chain.id === chainId\n        ? options.chain\n        : (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getCachedChain)(chainId);\n    // if we want a specific chainId and it is not the same as the provider chainId, trigger switchChain\n    if (options.chain && options.chain.id !== chainId) {\n        await switchChain(provider, options.chain);\n        connectedChain = options.chain;\n    }\n    return onConnect(provider, address, connectedChain, emitter);\n}\n/**\n * @internal\n */\nasync function autoConnectInjectedWallet(id, emitter, chain) {\n    const provider = getInjectedProvider(id);\n    // connected accounts\n    const addresses = await provider.request({\n        method: \"eth_accounts\",\n    });\n    const addr = addresses[0];\n    if (!addr) {\n        throw new Error(\"no accounts available\");\n    }\n    // use the first account\n    const address = (0,_utils_address_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(addr);\n    // get the chainId the provider is on\n    const chainId = await provider\n        .request({ method: \"eth_chainId\" })\n        .then(_utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__.normalizeChainId);\n    const connectedChain = chain && chain.id === chainId ? chain : (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getCachedChain)(chainId);\n    return onConnect(provider, address, connectedChain, emitter);\n}\nfunction createAccount(provider, address) {\n    const account = {\n        address,\n        async sendTransaction(tx) {\n            const transactionHash = (await provider.request({\n                method: \"eth_sendTransaction\",\n                params: [\n                    {\n                        accessList: tx.accessList,\n                        value: tx.value ? (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.numberToHex)(tx.value) : undefined,\n                        gas: tx.gas ? (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.numberToHex)(tx.gas) : undefined,\n                        from: this.address,\n                        to: tx.to,\n                        data: tx.data,\n                    },\n                ],\n            }));\n            return {\n                transactionHash,\n            };\n        },\n        async signMessage({ message }) {\n            if (!account.address) {\n                throw new Error(\"Provider not setup\");\n            }\n            const messageToSign = (() => {\n                if (typeof message === \"string\") {\n                    return (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.stringToHex)(message);\n                }\n                if (message.raw instanceof Uint8Array) {\n                    return (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.uint8ArrayToHex)(message.raw);\n                }\n                return message.raw;\n            })();\n            return await provider.request({\n                method: \"personal_sign\",\n                params: [messageToSign, account.address],\n            });\n        },\n        async signTypedData(typedData) {\n            if (!provider || !account.address) {\n                throw new Error(\"Provider not setup\");\n            }\n            const parsedTypedData = (0,_utils_signatures_helpers_parseTypedData_js__WEBPACK_IMPORTED_MODULE_5__.parseTypedData)(typedData);\n            const { domain, message, primaryType } = parsedTypedData;\n            const types = {\n                EIP712Domain: (0,viem__WEBPACK_IMPORTED_MODULE_6__.getTypesForEIP712Domain)({ domain }),\n                ...parsedTypedData.types,\n            };\n            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n            // as we can't statically check this with TypeScript.\n            (0,viem__WEBPACK_IMPORTED_MODULE_6__.validateTypedData)({ domain, message, primaryType, types });\n            const stringifiedData = (0,viem__WEBPACK_IMPORTED_MODULE_6__.serializeTypedData)({\n                domain: domain ?? {},\n                message,\n                primaryType,\n                types,\n            });\n            return await provider.request({\n                method: \"eth_signTypedData_v4\",\n                params: [account.address, stringifiedData],\n            });\n        },\n    };\n    return account;\n}\n/**\n * Call this method when the wallet provider is connected or auto connected\n * @internal\n */\nasync function onConnect(provider, address, chain, emitter) {\n    const account = createAccount(provider, address);\n    async function disconnect() {\n        provider.removeListener(\"accountsChanged\", onAccountsChanged);\n        provider.removeListener(\"chainChanged\", onChainChanged);\n        provider.removeListener(\"disconnect\", onDisconnect);\n    }\n    function onDisconnect() {\n        disconnect();\n        emitter.emit(\"disconnect\", undefined);\n    }\n    function onAccountsChanged(accounts) {\n        if (accounts[0]) {\n            const newAccount = createAccount(provider, (0,_utils_address_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(accounts[0]));\n            emitter.emit(\"accountChanged\", newAccount);\n            emitter.emit(\"accountsChanged\", accounts);\n        }\n        else {\n            onDisconnect();\n        }\n    }\n    function onChainChanged(newChainId) {\n        const newChain = (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getCachedChain)((0,_utils_normalizeChainId_js__WEBPACK_IMPORTED_MODULE_2__.normalizeChainId)(newChainId));\n        emitter.emit(\"chainChanged\", newChain);\n    }\n    if (provider.on) {\n        provider.on(\"accountsChanged\", onAccountsChanged);\n        provider.on(\"chainChanged\", onChainChanged);\n        provider.on(\"disconnect\", onDisconnect);\n    }\n    return [\n        account,\n        chain,\n        disconnect,\n        (newChain) => switchChain(provider, newChain),\n    ];\n}\n/**\n * @internal\n */\nasync function switchChain(provider, chain) {\n    const hexChainId = (0,_utils_encoding_hex_js__WEBPACK_IMPORTED_MODULE_4__.numberToHex)(chain.id);\n    try {\n        await provider.request({\n            method: \"wallet_switchEthereumChain\",\n            params: [{ chainId: hexChainId }],\n        });\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n    }\n    catch (e) {\n        // if chain does not exist, add the chain\n        if (e?.code === 4902 || e?.data?.originalError?.code === 4902) {\n            const apiChain = await (0,_chains_utils_js__WEBPACK_IMPORTED_MODULE_3__.getChainMetadata)(chain);\n            await provider.request({\n                method: \"wallet_addEthereumChain\",\n                params: [\n                    {\n                        chainId: hexChainId,\n                        chainName: apiChain.name,\n                        nativeCurrency: apiChain.nativeCurrency,\n                        rpcUrls: (0,_utils_chains_js__WEBPACK_IMPORTED_MODULE_7__.getValidPublicRPCUrl)(apiChain), // no client id on purpose here\n                        blockExplorerUrls: apiChain.explorers?.map((x) => x.url),\n                    },\n                ],\n            });\n        }\n        else {\n            throw e;\n        }\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS93YWxsZXRzL2luamVjdGVkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF1RjtBQUNkO0FBQ3JCO0FBQ3FDO0FBQy9CO0FBQ007QUFDZDtBQUNnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGFBQWEsK0RBQWdCO0FBQzdCO0FBQ0E7QUFDTztBQUNQLHFCQUFxQiwrREFBZ0I7QUFDckM7QUFDQSxtRUFBbUUsU0FBUztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUFVO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLGNBQWMsd0VBQWdCO0FBQzlCO0FBQ0E7QUFDQSxVQUFVLGdFQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUFVO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLGNBQWMsd0VBQWdCO0FBQzlCLG1FQUFtRSxnRUFBYztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1FQUFXO0FBQ3JELHNDQUFzQyxtRUFBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUVBQVc7QUFDdEM7QUFDQTtBQUNBLDJCQUEyQix1RUFBZTtBQUMxQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkZBQWM7QUFDbEQsb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBLDhCQUE4Qiw2REFBdUIsR0FBRyxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBaUIsR0FBRyxxQ0FBcUM7QUFDckUsb0NBQW9DLHdEQUFrQjtBQUN0RCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw2REFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdFQUFjLENBQUMsNEVBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtRUFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtFQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzRUFBb0I7QUFDckQ7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vd2FsbGV0cy9pbmplY3RlZC9pbmRleC5qcz81OWI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFR5cGVzRm9yRUlQNzEyRG9tYWluLCBzZXJpYWxpemVUeXBlZERhdGEsIHZhbGlkYXRlVHlwZWREYXRhLCB9IGZyb20gXCJ2aWVtXCI7XG5pbXBvcnQgeyBnZXRDYWNoZWRDaGFpbiwgZ2V0Q2hhaW5NZXRhZGF0YSB9IGZyb20gXCIuLi8uLi9jaGFpbnMvdXRpbHMuanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi4vLi4vdXRpbHMvYWRkcmVzcy5qc1wiO1xuaW1wb3J0IHsgbnVtYmVyVG9IZXgsIHN0cmluZ1RvSGV4LCB1aW50OEFycmF5VG9IZXgsIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2VuY29kaW5nL2hleC5qc1wiO1xuaW1wb3J0IHsgZ2V0VmFsaWRQdWJsaWNSUENVcmwgfSBmcm9tIFwiLi4vdXRpbHMvY2hhaW5zLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVDaGFpbklkIH0gZnJvbSBcIi4uL3V0aWxzL25vcm1hbGl6ZUNoYWluSWQuanNcIjtcbmltcG9ydCB7IGluamVjdGVkUHJvdmlkZXIgfSBmcm9tIFwiLi9taXBkU3RvcmUuanNcIjtcbmltcG9ydCB7IHBhcnNlVHlwZWREYXRhIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3NpZ25hdHVyZXMvaGVscGVycy9wYXJzZVR5cGVkRGF0YS5qc1wiO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIHdhbGxldCBpcyBhbiBpbmplY3RlZCB3YWxsZXQuXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB3YWxsZXQgaXMgYW4gaW5qZWN0ZWQgd2FsbGV0LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0luamVjdGVkV2FsbGV0KHdhbGxldCkge1xuICAgIHJldHVybiAhIWluamVjdGVkUHJvdmlkZXIod2FsbGV0LmlkKTtcbn1cbi8vIFRPRE86IHNhdmUgdGhlIHByb3ZpZGVyIGluIGRhdGFcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmplY3RlZFByb3ZpZGVyKHdhbGxldElkKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBpbmplY3RlZFByb3ZpZGVyKHdhbGxldElkKTtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gaW5qZWN0ZWQgcHJvdmlkZXIgZm91bmQgZm9yIHdhbGxldDogXCIke3dhbGxldElkfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlcjtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25uZWN0SW5qZWN0ZWRXYWxsZXQoaWQsIG9wdGlvbnMsIGVtaXR0ZXIpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGdldEluamVjdGVkUHJvdmlkZXIoaWQpO1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFwiZXRoX3JlcXVlc3RBY2NvdW50c1wiLFxuICAgIH0pO1xuICAgIGNvbnN0IGFkZHIgPSBhZGRyZXNzZXNbMF07XG4gICAgaWYgKCFhZGRyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGFjY291bnRzIGF2YWlsYWJsZVwiKTtcbiAgICB9XG4gICAgLy8gdXNlIHRoZSBmaXJzdCBhY2NvdW50XG4gICAgY29uc3QgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcik7XG4gICAgLy8gZ2V0IHRoZSBjaGFpbklkIHRoZSBwcm92aWRlciBpcyBvblxuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlclxuICAgICAgICAucmVxdWVzdCh7IG1ldGhvZDogXCJldGhfY2hhaW5JZFwiIH0pXG4gICAgICAgIC50aGVuKG5vcm1hbGl6ZUNoYWluSWQpO1xuICAgIGxldCBjb25uZWN0ZWRDaGFpbiA9IG9wdGlvbnMuY2hhaW4gJiYgb3B0aW9ucy5jaGFpbi5pZCA9PT0gY2hhaW5JZFxuICAgICAgICA/IG9wdGlvbnMuY2hhaW5cbiAgICAgICAgOiBnZXRDYWNoZWRDaGFpbihjaGFpbklkKTtcbiAgICAvLyBpZiB3ZSB3YW50IGEgc3BlY2lmaWMgY2hhaW5JZCBhbmQgaXQgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBwcm92aWRlciBjaGFpbklkLCB0cmlnZ2VyIHN3aXRjaENoYWluXG4gICAgaWYgKG9wdGlvbnMuY2hhaW4gJiYgb3B0aW9ucy5jaGFpbi5pZCAhPT0gY2hhaW5JZCkge1xuICAgICAgICBhd2FpdCBzd2l0Y2hDaGFpbihwcm92aWRlciwgb3B0aW9ucy5jaGFpbik7XG4gICAgICAgIGNvbm5lY3RlZENoYWluID0gb3B0aW9ucy5jaGFpbjtcbiAgICB9XG4gICAgcmV0dXJuIG9uQ29ubmVjdChwcm92aWRlciwgYWRkcmVzcywgY29ubmVjdGVkQ2hhaW4sIGVtaXR0ZXIpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF1dG9Db25uZWN0SW5qZWN0ZWRXYWxsZXQoaWQsIGVtaXR0ZXIsIGNoYWluKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBnZXRJbmplY3RlZFByb3ZpZGVyKGlkKTtcbiAgICAvLyBjb25uZWN0ZWQgYWNjb3VudHNcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcImV0aF9hY2NvdW50c1wiLFxuICAgIH0pO1xuICAgIGNvbnN0IGFkZHIgPSBhZGRyZXNzZXNbMF07XG4gICAgaWYgKCFhZGRyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGFjY291bnRzIGF2YWlsYWJsZVwiKTtcbiAgICB9XG4gICAgLy8gdXNlIHRoZSBmaXJzdCBhY2NvdW50XG4gICAgY29uc3QgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWRkcik7XG4gICAgLy8gZ2V0IHRoZSBjaGFpbklkIHRoZSBwcm92aWRlciBpcyBvblxuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlclxuICAgICAgICAucmVxdWVzdCh7IG1ldGhvZDogXCJldGhfY2hhaW5JZFwiIH0pXG4gICAgICAgIC50aGVuKG5vcm1hbGl6ZUNoYWluSWQpO1xuICAgIGNvbnN0IGNvbm5lY3RlZENoYWluID0gY2hhaW4gJiYgY2hhaW4uaWQgPT09IGNoYWluSWQgPyBjaGFpbiA6IGdldENhY2hlZENoYWluKGNoYWluSWQpO1xuICAgIHJldHVybiBvbkNvbm5lY3QocHJvdmlkZXIsIGFkZHJlc3MsIGNvbm5lY3RlZENoYWluLCBlbWl0dGVyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjY291bnQocHJvdmlkZXIsIGFkZHJlc3MpIHtcbiAgICBjb25zdCBhY2NvdW50ID0ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IChhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NMaXN0OiB0eC5hY2Nlc3NMaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4LnZhbHVlID8gbnVtYmVyVG9IZXgodHgudmFsdWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FzOiB0eC5nYXMgPyBudW1iZXJUb0hleCh0eC5nYXMpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBzaWduTWVzc2FnZSh7IG1lc3NhZ2UgfSkge1xuICAgICAgICAgICAgaWYgKCFhY2NvdW50LmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3Qgc2V0dXBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlVG9TaWduID0gKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1RvSGV4KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5yYXcgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1aW50OEFycmF5VG9IZXgobWVzc2FnZS5yYXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5yYXc7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJwZXJzb25hbF9zaWduXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbbWVzc2FnZVRvU2lnbiwgYWNjb3VudC5hZGRyZXNzXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBzaWduVHlwZWREYXRhKHR5cGVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlciB8fCAhYWNjb3VudC5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZXIgbm90IHNldHVwXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkVHlwZWREYXRhID0gcGFyc2VUeXBlZERhdGEodHlwZWREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9tYWluLCBtZXNzYWdlLCBwcmltYXJ5VHlwZSB9ID0gcGFyc2VkVHlwZWREYXRhO1xuICAgICAgICAgICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgICAgICAgICAgRUlQNzEyRG9tYWluOiBnZXRUeXBlc0ZvckVJUDcxMkRvbWFpbih7IGRvbWFpbiB9KSxcbiAgICAgICAgICAgICAgICAuLi5wYXJzZWRUeXBlZERhdGEudHlwZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gTmVlZCB0byBkbyBhIHJ1bnRpbWUgdmFsaWRhdGlvbiBjaGVjayBvbiBhZGRyZXNzZXMsIGJ5dGUgcmFuZ2VzLCBpbnRlZ2VyIHJhbmdlcywgZXRjXG4gICAgICAgICAgICAvLyBhcyB3ZSBjYW4ndCBzdGF0aWNhbGx5IGNoZWNrIHRoaXMgd2l0aCBUeXBlU2NyaXB0LlxuICAgICAgICAgICAgdmFsaWRhdGVUeXBlZERhdGEoeyBkb21haW4sIG1lc3NhZ2UsIHByaW1hcnlUeXBlLCB0eXBlcyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkRGF0YSA9IHNlcmlhbGl6ZVR5cGVkRGF0YSh7XG4gICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4gPz8ge30sXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5VHlwZSxcbiAgICAgICAgICAgICAgICB0eXBlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW2FjY291bnQuYWRkcmVzcywgc3RyaW5naWZpZWREYXRhXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIGFjY291bnQ7XG59XG4vKipcbiAqIENhbGwgdGhpcyBtZXRob2Qgd2hlbiB0aGUgd2FsbGV0IHByb3ZpZGVyIGlzIGNvbm5lY3RlZCBvciBhdXRvIGNvbm5lY3RlZFxuICogQGludGVybmFsXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG9uQ29ubmVjdChwcm92aWRlciwgYWRkcmVzcywgY2hhaW4sIGVtaXR0ZXIpIHtcbiAgICBjb25zdCBhY2NvdW50ID0gY3JlYXRlQWNjb3VudChwcm92aWRlciwgYWRkcmVzcyk7XG4gICAgYXN5bmMgZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoXCJhY2NvdW50c0NoYW5nZWRcIiwgb25BY2NvdW50c0NoYW5nZWQpO1xuICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcihcImNoYWluQ2hhbmdlZFwiLCBvbkNoYWluQ2hhbmdlZCk7XG4gICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKFwiZGlzY29ubmVjdFwiLCBvbkRpc2Nvbm5lY3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZW1pdHRlci5lbWl0KFwiZGlzY29ubmVjdFwiLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkFjY291bnRzQ2hhbmdlZChhY2NvdW50cykge1xuICAgICAgICBpZiAoYWNjb3VudHNbMF0pIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0FjY291bnQgPSBjcmVhdGVBY2NvdW50KHByb3ZpZGVyLCBnZXRBZGRyZXNzKGFjY291bnRzWzBdKSk7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoXCJhY2NvdW50Q2hhbmdlZFwiLCBuZXdBY2NvdW50KTtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCBhY2NvdW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkNoYWluQ2hhbmdlZChuZXdDaGFpbklkKSB7XG4gICAgICAgIGNvbnN0IG5ld0NoYWluID0gZ2V0Q2FjaGVkQ2hhaW4obm9ybWFsaXplQ2hhaW5JZChuZXdDaGFpbklkKSk7XG4gICAgICAgIGVtaXR0ZXIuZW1pdChcImNoYWluQ2hhbmdlZFwiLCBuZXdDaGFpbik7XG4gICAgfVxuICAgIGlmIChwcm92aWRlci5vbikge1xuICAgICAgICBwcm92aWRlci5vbihcImFjY291bnRzQ2hhbmdlZFwiLCBvbkFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgIHByb3ZpZGVyLm9uKFwiY2hhaW5DaGFuZ2VkXCIsIG9uQ2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgcHJvdmlkZXIub24oXCJkaXNjb25uZWN0XCIsIG9uRGlzY29ubmVjdCk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIGFjY291bnQsXG4gICAgICAgIGNoYWluLFxuICAgICAgICBkaXNjb25uZWN0LFxuICAgICAgICAobmV3Q2hhaW4pID0+IHN3aXRjaENoYWluKHByb3ZpZGVyLCBuZXdDaGFpbiksXG4gICAgXTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN3aXRjaENoYWluKHByb3ZpZGVyLCBjaGFpbikge1xuICAgIGNvbnN0IGhleENoYWluSWQgPSBudW1iZXJUb0hleChjaGFpbi5pZCk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6IFwid2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW5cIixcbiAgICAgICAgICAgIHBhcmFtczogW3sgY2hhaW5JZDogaGV4Q2hhaW5JZCB9XSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9FeHBsaWNpdEFueTogVE9ETzogZml4IGFueVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZiBjaGFpbiBkb2VzIG5vdCBleGlzdCwgYWRkIHRoZSBjaGFpblxuICAgICAgICBpZiAoZT8uY29kZSA9PT0gNDkwMiB8fCBlPy5kYXRhPy5vcmlnaW5hbEVycm9yPy5jb2RlID09PSA0OTAyKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlDaGFpbiA9IGF3YWl0IGdldENoYWluTWV0YWRhdGEoY2hhaW4pO1xuICAgICAgICAgICAgYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIndhbGxldF9hZGRFdGhlcmV1bUNoYWluXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGhleENoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbk5hbWU6IGFwaUNoYWluLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeTogYXBpQ2hhaW4ubmF0aXZlQ3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBycGNVcmxzOiBnZXRWYWxpZFB1YmxpY1JQQ1VybChhcGlDaGFpbiksIC8vIG5vIGNsaWVudCBpZCBvbiBwdXJwb3NlIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzOiBhcGlDaGFpbi5leHBsb3JlcnM/Lm1hcCgoeCkgPT4geC51cmwpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/wallets/injected/index.js\n"));

/***/ })

}]);